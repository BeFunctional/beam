Common table expressions are a SQL99 feature that allow you to reuse common
subqueries in your queries. There is often no semantic difference between CTEs
and reusing Beam queries, but backends sometimes have optimizations that will
only fire when using CTEs. Common table expressions are also necessary to write
*recursive* queries.

## The `selectWith` function

!beam-query
```haskell
!example chinookdml cte
void $ runSelectReturningList $ selectWith $ do
  albumGenreCountQ <-
    selecting $
    withWindow_ (\(albumId, _, _) -> frame_ (partitionBy_ albumId) noOrder_ noBounds_)
                (\(albumId, genreId, trackCnt) albumWindow ->
                    (albumId, genreId, trackCnt, max_ trackCnt `over_` albumWindow)) $
    aggregate_ (\t -> ( group_ (trackAlbumId t)
                      , group_ (trackGenreId t)
                      , as_ @Int countAll_ )) $
    all_ (track chinookDb)

  pure $ do
    (albumId@(AlbumId albumIdColumn), genreId, _, _) <-
       filter_' (\(_, _, trackCnt, maxTrackCntInAlbum) ->
                     just_ trackCnt ==?. maxTrackCntInAlbum) $
       reuse albumGenreCountQ
    genre_ <- join_' (genre chinookDb) (\g -> genreId ==?. just_ (primaryKey g))
    album_ <- join_' (album chinookDb) (\a -> albumId ==?. just_ (primaryKey a))
    artist_ <- join_ (artist chinookDb) (\a -> albumArtist album_ `references_` a)

    guard_' (albumIdColumn ==*.
             anyOf_ (orderBy_ asc_ $ fmap fst $
                     filter_ (\(_, genreCntByAlbum) -> genreCntByAlbum >. 1) $
                     aggregate_ (\t -> let GenreId genreId = trackGenreId t
                                           AlbumId albumId = trackAlbumId t
                                       in ( group_ albumId
                                          , as_ @Int (countOver_ distinctInGroup_ genreId))) $
                     all_ (track chinookDb)))

    pure ( artistName artist_, albumTitle album_, genreName genre_ )
```

## Binding subqueries with `selecting`

## Recursive queries
